<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OODA WIKI | Final Animation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        /* Layer 3: Farthest Back (CSS Animated Background) */
        #css-animated-bg {
            background-image: url('https://www.transparenttextures.com/patterns/stardust.png');
            background-color: #050A10;
            animation: scroll-background 120s linear infinite;
            z-index: 1;
        }
        @keyframes scroll-background {
            from { background-position: 0 0; }
            to { background-position: -1024px 1024px; }
        }

        /* Layer 2: Main three.js scene (Logo + Afterburner) */
        #three-js-canvas { z-index: 2; }

        /* Layer 1: Interactive particles.js foreground */
        #particles-js-fg { z-index: 3; }
    </style>
</head>
<body>
    <!-- The three-layer structure -->
    <div id="css-animated-bg" class="layer"></div>
    <div id="three-js-canvas" class="layer"></div>
    <div id="particles-js-fg" class="layer"></div>

    <!-- NOTE: We must use the modern importmap structure to support the afterburner code exactly. -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js"
        }
    }
    </script>
    
    <!-- The `particles.js` library script -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>

    <!-- This is the Three.js afterburner script, transplanted and adapted for layering -->
    <script type="module">
        import * as THREE from 'three';
        
        // This entire block of code is from your preferred afterburner example.
        // Only the renderer setup has been slightly modified to fit the layers.

        // --- CONFIGURATION ---
        const LOGO_URL = './OODA Genesis Transparent.png';
        const LOGO_WIDTH = 8;
        
        // --- Flame Particles ---
        const FLAME_PARTICLE_COUNT = 80000;
        const FLAME_SPEED = 0.1;
        const FLAME_COLORS = [new THREE.Color(0xffffff), new THREE.Color(0xffaa00), new THREE.Color(0xff4400)];
        const FLAME_TRAIL_LENGTH = 15.0;

        // --- Smoke Particles ---
        const SMOKE_PARTICLE_COUNT = 80000;
        const SMOKE_SPEED = 0.08;
        const SMOKE_COLORS = [new THREE.Color(0xffffff), new THREE.Color(0x5A6468), new THREE.Color(0x88aaff)];
        const SMOKE_TRAIL_LENGTH = 25.0;

        // --- SETUP ---
        const container = document.getElementById('three-js-canvas'); // Target the correct div
        let scene, camera, renderer, clock;
        let flameParticles, smokeParticles;
        let startPositions;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;
            
            // --- MODIFIED RENDERER SETUP ---
            // These settings are critical for placing it in the multi-layer structure.
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha:true is essential
            renderer.setClearColor(0x000000, 0); // Makes the canvas background transparent
            // --- END MODIFICATION ---

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            container.appendChild(renderer.domElement); // Append to our specific container div

            clock = new THREE.Clock();
            loadLogoAndInitSimulation();
            window.addEventListener('resize', onWindowResize);
        }

        // --- ALL FUNCTIONS BELOW ARE IDENTICAL TO YOUR PREFERRED EXAMPLE ---

        function loadLogoAndInitSimulation() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(LOGO_URL, (texture) => {
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;

                const logoAspect = texture.image.width / texture.image.height;
                const logoHeight = LOGO_WIDTH / logoAspect;
                const logoMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, depthTest: false });
                const logoPlane = new THREE.Mesh(new THREE.PlaneGeometry(LOGO_WIDTH, logoHeight), logoMaterial);
                scene.add(logoPlane);

                const image = texture.image;
                const canvas = document.createElement('canvas');
                canvas.width = image.width;
                canvas.height = image.height;
                const context = canvas.getContext('2d');
                context.drawImage(image, 0, 0);
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                
                const positions = [];
                const density = 1;
                for (let y = 0; y < canvas.height; y += density) {
                    for (let x = 0; x < canvas.width; x += density) {
                        if (imageData.data[(y * canvas.width + x) * 4 + 3] > 50) {
                            positions.push((x / canvas.width - 0.5) * LOGO_WIDTH, (-y / canvas.height + 0.5) * logoHeight, 0);
                        }
                    }
                }
                startPositions = new Float32Array(positions);

                createFlameParticles();
                createSmokeParticles();
                animate();
            }, undefined, (err) => {
                console.error('Error loading logo.', err);
            });
        }

        function createFlameParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(FLAME_PARTICLE_COUNT * 3);
            const colors = new Float32Array(FLAME_PARTICLE_COUNT * 3);
            const initialVelocities = new Float32Array(FLAME_PARTICLE_COUNT * 3);

            for (let i = 0; i < FLAME_PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const randomIndex = Math.floor(Math.random() * (startPositions.length / 3)) * 3;
                positions[i3] = startPositions[randomIndex];
                positions[i3 + 1] = startPositions[randomIndex + 1];
                positions[i3 + 2] = Math.random() * -FLAME_TRAIL_LENGTH;
                
                const color = FLAME_COLORS[Math.floor(Math.random() * FLAME_COLORS.length)];
                colors[i3] = color.r; colors[i3 + 1] = color.g; colors[i3 + 2] = color.b;

                initialVelocities[i3] = (Math.random() - 0.5) * 0.01;
                initialVelocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
                initialVelocities[i3 + 2] = -FLAME_SPEED;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('initialVelocity', new THREE.BufferAttribute(initialVelocities, 3));

            const material = new THREE.PointsMaterial({
                size: 0.04, vertexColors: true, blending: THREE.AdditiveBlending, 
                transparent: true, depthWrite: false, opacity: 0.8,
                map: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/spark1.png')
            });

            flameParticles = new THREE.Points(geometry, material);
            scene.add(flameParticles);
        }

        function createSmokeParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(SMOKE_PARTICLE_COUNT * 3);
            const colors = new Float32Array(SMOKE_PARTICLE_COUNT * 3);
            const initialVelocities = new Float32Array(SMOKE_PARTICLE_COUNT * 3);

            for (let i = 0; i < SMOKE_PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const randomIndex = Math.floor(Math.random() * (startPositions.length / 3)) * 3;
                positions[i3] = startPositions[randomIndex];
                positions[i3 + 1] = startPositions[randomIndex + 1];
                positions[i3 + 2] = Math.random() * -SMOKE_TRAIL_LENGTH;

                const color = SMOKE_COLORS[Math.floor(Math.random() * SMOKE_COLORS.length)];
                colors[i3] = color.r; colors[i3 + 1] = color.g; colors[i3 + 2] = color.b;

                initialVelocities[i3] = (Math.random() - 0.5) * 0.02;
                initialVelocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                initialVelocities[i3 + 2] = -SMOKE_SPEED;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('initialVelocity', new THREE.BufferAttribute(initialVelocities, 3));

            const material = new THREE.PointsMaterial({
                size: 0.08, vertexColors: true, blending: THREE.NormalBlending, 
                transparent: true, depthWrite: false, opacity: 0.5,
                map: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/spark1.png')
            });

            smokeParticles = new THREE.Points(geometry, material);
            smokeParticles.position.z = -0.1;
            scene.add(smokeParticles);
        }

        function animate() {
            const delta = clock.getDelta();

            if (flameParticles) {
                const positions = flameParticles.geometry.attributes.position.array;
                const velocities = flameParticles.geometry.attributes.initialVelocity.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i] * delta * 10;
                    positions[i+1] += velocities[i+1] * delta * 10;
                    positions[i+2] += velocities[i+2] * delta * 10;
                    if (positions[i+2] < -FLAME_TRAIL_LENGTH) {
                        const randomIndex = Math.floor(Math.random() * (startPositions.length / 3)) * 3;
                        positions[i] = startPositions[randomIndex];
                        positions[i+1] = startPositions[randomIndex+1];
                        positions[i+2] = 0;
                    }
                }
                flameParticles.geometry.attributes.position.needsUpdate = true;
            }

            if (smokeParticles) {
                const positions = smokeParticles.geometry.attributes.position.array;
                const velocities = smokeParticles.geometry.attributes.initialVelocity.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i] * delta * 10;
                    positions[i+1] += velocities[i+1] * delta * 10;
                    positions[i+2] += velocities[i+2] * delta * 10;
                    if (positions[i+2] < -SMOKE_TRAIL_LENGTH) {
                        const randomIndex = Math.floor(Math.random() * (startPositions.length / 3)) * 3;
                        positions[i] = startPositions[randomIndex];
                        positions[i+1] = startPositions[randomIndex+1];
                        positions[i+2] = 0;
                    }
                }
                smokeParticles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
    
    <!-- This is the unchanged particles.js script for the foreground layer -->
    <script>
        particlesJS("particles-js-fg", {
            "particles": {
                "number": { "value": 80, "density": { "enable": true, "value_area": 800 } },
                "color": { "value": "#ffffff" },
                "shape": { "type": "circle" },
                "opacity": { "value": 0.5, "random": true },
                "size": { "value": 3, "random": true },
                "move": { "enable": true, "speed": 1, "direction": "none", "random": true, "straight": false, "out_mode": "out" }
            },
            "interactivity": {
                "events": { "onhover": { "enable": true, "mode": "repulse" } },
                "modes": { "repulse": { "distance": 150, "duration": 0.4 } }
            }
        });
    </script>
</body>
</html>